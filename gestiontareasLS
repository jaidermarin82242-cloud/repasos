CONTEXTO

Una empresa necesita un sistema para gestionar tareas de un proyecto usando una lista enlazada simple.

Cada tarea tiene:

nombre

responsable

prioridad (1â€“5)

estado (pendiente o completada)

âš ï¸ REGLAS

âŒ No usar listas de Python []

âœ” Usar lista enlazada simple

âœ” Usar recursividad donde se indique

âœ” Mantener tareas ORDENADAS por prioridad (mayor primero)

REQUERIMIENTOS
ðŸ”¹ PUNTO 1 (1.0) â€“ DiseÃ±o
Clase Nodo Tarea

Debe almacenar:

nombre

responsable

prioridad

completada (bool)

siguiente

Clase Lista Proyecto

Debe mantener:

referencia al inicio

ðŸ”¹ PUNTO 2 (1.25) â€“ AGREGAR TAREA ORDENADA (RECURSIVO)

Insertar tarea respetando orden descendente por prioridad.

Ejemplo:

5 â†’ 4 â†’ 3 â†’ 2 â†’ 1
ðŸ”¹ PUNTO 3 (0.75) â€“ CONTAR TAREAS PENDIENTES DE CIERTA PRIORIDAD (RECURSIVO)

Ejemplo:

contar_pendientes(5)
ðŸ”¹ PUNTO 4 (1.0) â€“ OBTENER TAREAS DE UN RESPONSABLE (RECURSIVO)

Debe retornar una NUEVA lista con las tareas de ese responsable.

No modificar la lista original.

ðŸ”¹ PUNTO 5 (1.0) â€“ ELIMINAR TAREAS COMPLETADAS (RECURSIVO)

Modificar la lista original.

âœ… SOLUCIÃ“N COMPLETA
# PUNTO 1 - Clase Nodo
class Tarea:
    def __init__(self, nombre, responsable, prioridad, completada=False):
        self.nombre = nombre
        self.responsable = responsable
        self.prioridad = prioridad
        self.completada = completada
        self.siguiente = None


# Clase Lista
class Proyecto:
    def __init__(self):
        self.inicio = None

    # PUNTO 2 - Agregar ordenado por prioridad (recursivo)
    def agregar(self, nombre, responsable, prioridad):
        nueva = Tarea(nombre, responsable, prioridad)

        def recursivo(nodo):
            if nodo is None or prioridad > nodo.prioridad:
                nueva.siguiente = nodo
                return nueva
            nodo.siguiente = recursivo(nodo.siguiente)
            return nodo

        self.inicio = recursivo(self.inicio)

    # PUNTO 3 - Contar pendientes por prioridad (recursivo)
    def contar_pendientes(self, prioridad):
        def recursivo(nodo):
            if nodo is None:
                return 0
            cuenta = 0
            if nodo.prioridad == prioridad and not nodo.completada:
                cuenta = 1
            return cuenta + recursivo(nodo.siguiente)

        return recursivo(self.inicio)

    # PUNTO 4 - Obtener tareas de un responsable (recursivo)
    def tareas_de_responsable(self, responsable):
        nueva = Proyecto()

        def recursivo(nodo):
            if nodo is None:
                return
            recursivo(nodo.siguiente)
            if nodo.responsable == responsable:
                nueva.agregar(nodo.nombre, nodo.responsable, nodo.prioridad)

        recursivo(self.inicio)
        return nueva

    # PUNTO 5 - Eliminar completadas (recursivo)
    def eliminar_completadas(self):
        def recursivo(nodo):
            if nodo is None:
                return None
            if nodo.completada:
                return recursivo(nodo.siguiente)
            nodo.siguiente = recursivo(nodo.siguiente)
            return nodo

        self.inicio = recursivo(self.inicio)

    # MÃ©todo auxiliar
    def completar(self, nombre):
        actual = self.inicio
        while actual:
            if actual.nombre == nombre:
                actual.completada = True
                return True
            actual = actual.siguiente
        return False

    def mostrar(self):
        actual = self.inicio
        while actual:
            estado = "âœ“" if actual.completada else "â—‹"
            print(f"[{estado}] {actual.nombre} - {actual.responsable} (Prioridad {actual.prioridad})")
            actual = actual.siguiente
